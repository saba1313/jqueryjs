<?php
// ; $Id: taxonomy_super_select.module,v 1.7 2007/02/20 02:05:42 codexmas Exp $

function taxonomy_super_select_form_alter($form_id, &$form) {
  // Taxonomy Edit Form
  if($form_id == 'taxonomy_form_vocabulary'){
    $vid = $form['#parameters'][1]['vid'];
    $vocab = taxonomy_get_vocabulary($vid);
    if($vocab){
      $tss = variable_get('taxonomy_super_select_vid_'.$vid, 0);
      // Position the name field higher
      $form['name']['#weight'] = -2;
      // Add our own submit handler
      $form['#submit']['taxonomy_super_select_submit'] = array();
      // Create fieldset and form elements
      $form['tss'] = array(
        '#type'         => 'fieldset',
        '#title'        => t('Taxonomy Super Select'),
        '#value'        => $info,
        '#collapsible'  => TRUE,
        '#collapsed'    => $tss ? FALSE : TRUE,
        '#tree'         => TRUE,
        '#weight'       => 0,
      );
      // Get list of all content types
      $types = node_get_types('names');
      // Loop through all types that are enabled for this vocab
      foreach($vocab->nodes AS $index => $type){
        $options[$type] = $types[$type];
      }
      $form['tss']['taxonomy_super_select_vid_'.$vid]['types'] = array(
        '#type'          => 'checkboxes',
        '#title'         => t('Enable Taxonomy Select for the Vocabulary Content Types Below'),
        '#options'       => $options,                              
        '#default_value' => $tss['types'],       
        '#weight'        => -1,
      );
      $form['tss']['taxonomy_super_select_vid_'.$vid]['parents'] = array(
        '#type'           => 'checkbox',
        '#title'          => t('Display parent terms as form items'),
        '#default_value'  => $tss['parents'],
        '#return_value'   => 1,
        '#weight'         => 0,
        '#description'    => t('Leaving this disabled forces users to select dangling child terms.  Useful for grouping terms with descriptive parent terms that are not themselves needed for display.'),
      );
      
    }                    
  }
  
  // Node Edit Form
  if(strstr($form_id,'_node_form') AND strstr($form['form_id']['#value'], '_node_form')){
    $content_type = $form['type']['#value'];
    // Get all vocabs for this content type
    $vocabularies = taxonomy_get_vocabularies($content_type);
    $valid_vocabs = array();
    foreach($vocabularies AS $vid => $vocabulary){
      $tss[$vid] = variable_get('taxonomy_super_select_vid_'.$vid, 0);
      // Only operate on types for a vocabulary that are enabled
      if($tss[$vid]['types'][$content_type]){
        // Show radio or checkbox based on the selection type
        $valid_vocabs[$vid] = $vocabulary->multiple ? 'checkbox' : 'radio';
        if($vocabulary->tags){
          // Remove any tags from the autocomplete form item (prevent duplicates)
          $tags[$vid] = $form['taxonomy']['tags'][$vid];
          $tags[$vid]['#default_value'] = '';
          $tags[$vid]['#required'] = FALSE;
          $tags[$vid]['#parents'] = array('taxonomy', 'tags', $vid);
          $tags[$vid]['#weight'] = -12;
          $tags[$vid]['#title'] = t('Enter New Tags');
          unset($form['taxonomy']['tags'][$vid]);
        }
        else{
          // Remove the default form rendering except for freetagging vocabs
          unset($form['taxonomy'][$vid]);
        }
      }
    }
    
    // Go through each enabled vocab and create taxonomy super select
    foreach($valid_vocabs AS $vid => $input){
      // Get root terms for vocabulary only
      $terms = taxonomy_get_tree($vid, 0, -1, 1);
      $form['taxonomy'][$vid] = _tss_branch($vid, $vocabularies[$vid]);
      if($tags[$vid]){
        $form['taxonomy'][$vid]['tags'] = $tags[$vid];
      }
      // First level terms
      foreach($terms AS $index => $term){
        $child1 = taxonomy_get_children($term->tid, $vid);
        if(count($child1)){
          if($tss[$vid]['parents']){
            $term->is_parent    = TRUE;
            $term->parent_type  = $input;
            $term->parent_value = $form['#node']->taxonomy[$term->tid]->tid;
          }
          $form['taxonomy'][$vid][$term->tid] = _tss_branch($vid, $term);
          // Second level terms
          foreach($child1 AS $c1tid => $c1term){
            $child2 = taxonomy_get_children($c1term->tid, $vid);
            if(count($child2)){
              if($tss[$vid]['parents']){
                $c1term->is_parent = TRUE;
                $c1term->parent_type  = $input;
                $c1term->parent_value = $form['#node']->taxonomy[$c1term->tid]->tid;
              }
              $form['taxonomy'][$vid][$term->tid][$c1term->tid] = _tss_branch($vid, $c1term);
              // Third level terms
              foreach($child2 AS $c2tid => $c2term){
                $child3 = taxonomy_get_children($c2term->tid, $vid);
                if(count($child3)){
                  if($tss[$vid]['parents']){
                    $c2term->is_parent = TRUE;
                    $c2term->parent_type  = $input;
                    $c2term->parent_value = $form['#node']->taxonomy[$c2term->tid]->tid;
                  }
                  $form['taxonomy'][$vid][$term->tid][$c1term->tid][$c2term->tid] = _tss_branch($vid, $c2term);
                  // Fourth level terms
                  foreach($child3 AS $c3tid => $c3term){
                    $child4 = taxonomy_get_children($c3term->tid, $vid);
                    if(count($child4)){
                      if($tss[$vid]['parents']){
                        $c3term->is_parent = TRUE;
                        $c3term->parent_type  = $input;
                        $c3term->parent_value = $form['#node']->taxonomy[$c3term->tid]->tid;
                      }
                      $form['taxonomy'][$vid][$term->tid][$c1term->tid][$c2term->tid][$c3term->tid] = _tss_branch($vid, $c3term);
                      // Fifth level terms
                      foreach($child4 AS $c4tid => $c4term){
                        $child5 = taxonomy_get_children($c4term->tid, $vid);
                        if(count($child5)){
                          if($tss[$vid]['parents']){
                            $c4term->is_parent = TRUE;
                            $c4term->parent_type  = $input;
                            $c4term->parent_value = $form['#node']->taxonomy[$c4term->tid]->tid;
                          }
                          $form['taxonomy'][$vid][$term->tid][$c1term->tid][$c2term->tid][$c3term->tid][$c4term->tid] = _tss_branch($vid, $c4term);
                        }
                        else{
                          if($c4value = $form['#node']->taxonomy[$c4term->tid]->tid){
                            $form['taxonomy'][$vid]['#collapsed'] = FALSE;
                            $form['taxonomy'][$vid][$term->tid]['#collapsed'] = FALSE;
                            $form['taxonomy'][$vid][$term->tid][$c1term->tid][$c2term->tid][$c3term->tid]['#collapsed'] = FALSE;
                          }
                          $form['taxonomy'][$vid][$term->tid][$c1term->tid][$c2term->tid][$c3term->tid][$c4term->tid] = _tss_branch($vid, $c4term, $c4value, $input);
                        }
                      }
                    }
                    else{
                      if($c3value = $form['#node']->taxonomy[$c3term->tid]->tid){
                        $form['taxonomy'][$vid]['#collapsed'] = FALSE;
                        $form['taxonomy'][$vid][$term->tid]['#collapsed'] = FALSE;
                        $form['taxonomy'][$vid][$term->tid][$c1term->tid][$c2term->tid]['#collapsed'] = FALSE;
                      }
                      $form['taxonomy'][$vid][$term->tid][$c1term->tid][$c2term->tid][$c3term->tid] = _tss_branch($vid, $c3term, $c3value, $input);
                    }
                  }
                }
                else{
                  if($c2value = $form['#node']->taxonomy[$c2term->tid]->tid){
                    $form['taxonomy'][$vid]['#collapsed'] = FALSE;
                    $form['taxonomy'][$vid][$term->tid]['#collapsed'] = FALSE;
                    $form['taxonomy'][$vid][$term->tid][$c1term->tid]['#collapsed'] = FALSE;
                  }
                  $form['taxonomy'][$vid][$term->tid][$c1term->tid][$c2term->tid] = _tss_branch($vid, $c2term, $c2value, $input);
                }
              }
            }
            else{
              if($c1value = $form['#node']->taxonomy[$c1term->tid]->tid){
                $form['taxonomy'][$vid]['#collapsed'] = FALSE;
                $form['taxonomy'][$vid][$term->tid]['#collapsed'] = FALSE;
              }
              $form['taxonomy'][$vid][$term->tid][$c1term->tid] = _tss_branch($vid, $c1term, $c1value, $input);
            }
          }
        }
        else{
          if($value = $form['#node']->taxonomy[$term->tid]->tid){
            $form['taxonomy'][$vid]['#collapsed'] = FALSE;
          }
          $form['taxonomy'][$vid][$term->tid] = _tss_branch($vid, $term, $value, $input);
        }
      }
    }
  } 
}

function _tss_branch($vid, $term, $value = NULL, $type = 'fieldset'){
  $required = $term->required ? ' <span class="form-required" title="'.t('This field is required.').'">*</span>' : '';
  switch($type){
    case 'fieldset':
      // Automatically expand required vocabs or if the parent term is selected
      $collapsed = ($required OR $term->parent_value) ? FALSE : TRUE;
      $form = array(
        '#type' => 'fieldset',
        '#title' => t($term->name).$required,
        '#collapsible' => TRUE,
        '#collapsed' => $collapsed, 
        '#weight' => $term->weight,
        '#parents' => array('taxonomy', $vid),
        '#description' => t($term->description),
      );
      // If we have vocabulary that is single select and not required or is freetagging we need a way to unselect the term
      if((!$required OR $term->tags) AND $term->multiple == 0 AND $term->module == 'taxonomy'){
        $form['none'] = array(
          '#type' => 'radio',
          '#title' => '<em>'.t('Select None').'</em>',
          '#return_value' => 0,
          '#default_value' => '',
          '#weight' => -12,
          '#parents' => array('taxonomy', $term->vid),
        );
      }
      if($term->is_parent){
        $term->weight = -11;
        $form['parent'] = _tss_branch($term->vid, $term, $term->parent_value, $term->parent_type);
      }
    break;
    case 'radio':
      $form = array(
        '#type' => 'radio',
        '#title' => ($term->is_parent ? '<strong>' : '').t($term->name).($term->is_parent ? '</strong>' : ''),
        '#return_value' => $term->tid,
        '#default_value' => $value,
        '#weight' => $term->weight,
        '#parents' => array('taxonomy', $vid),
      );
    break;
    case 'checkbox':
      $form = array(
        '#type' => 'checkbox',
        '#title' => ($term->is_parent ? '<strong>' : '').t($term->name).($term->is_parent ? '</strong>' : ''),
        '#return_value' => $term->tid,
        '#default_value' => $value,
        '#weight' => $term->weight,
        
      );
    break;
  }
  return $form;
}

function taxonomy_super_select_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL){
  if($op == 'validate'){
    // Content type agnostic so far, look for any node that has a vocabulary we handle
    if(count($node->taxonomy)){
      foreach($node->taxonomy AS $vid => $terms){
        // Only check vocabularies present
        if(is_numeric($vid)){
          $tss = variable_get('taxonomy_super_select_vid_'.$vid, FALSE);
          // Validation required
          if($tss['types'][$node->type]){
            $vocabulary = taxonomy_get_vocabulary($vid);
            $single = TRUE;
            $has_term = FALSE;
            // Check for freetagging items in the form
            if($vocabulary->tags){
              if($node->taxonomy['tags'][$vid] != ''){
                $free = explode(', ', $node->taxonomy['tags'][$vid]);
                $has_term = TRUE;
              }
            }
            else{
              $free = FALSE;
            }
            if($vocabulary->required){
              // Checkboxes
              if($vocabulary->multiple){
                // Loop through all the terms as unchecked checkboxes return zero which fools the FAPI required code
                foreach($terms AS $tid => $value){
                  // Check the freetagging form item for duplicate selected terms
                  if($vocabulary->tags AND $free){
                    if($value){
                      $this_term = taxonomy_get_term($value);
                      $found = array_search($this_term->name, $free);
                      if($found !== FALSE){
                        $duplicates[$vid] .= '"'.t($this_term->name).'" ';
                      }
                    }
                  }
                  // Regular flat list of terms
                  if($value > 0){
                    $has_term = TRUE;
                  }
                }
              }
              else{
                // Radio box that is single select and required
                if($free AND $terms){
                  $single = FALSE;
                }
                elseif($terms){
                  $has_term = TRUE;
                }
              }
            }
            // Not required phase
            else{
              // Radio Select
              if($vocabulary->multiple == 0){
                if($free AND $terms){
                  $single = FALSE;
                }
                elseif($free XOR $terms){
                  $has_term = TRUE;
                }
              }
              // Checkboxes
              else{
                if(is_array($terms)){
                  // Freetagging terms are present
                  if(count($free)){
                    foreach($terms AS $tid => $value){
                      // Terms set in vocab
                      if($value > 0){
                        $single = FALSE;
                      }
                    }
                  }
                }
              } 
            }
            // Catch freetagging vocabs that are single select with a radio checked as well as a new tag
            if(!$single AND !$vocabulary->multiple){
              form_set_error('taxonomy][tags]['.$vid, t('Only one selection allowed for %vocab', array('%vocab' => $vocabulary->name)));
            }
            // Catch required vocabs with no terms or freetagging entries
            if(!$has_term AND $vocabulary->required){
              form_set_error('taxonomy]['.$vid, t('%vocab is required.', array('%vocab' => $vocabulary->name)));
            }
            // Catch freetagging terms that are duplicated in the vocab already
            if($duplicates){
              // Display duplicate terms for each vocabulary that is freetagging
              foreach($duplicates AS $vid => $terms){
                // Warn user that they have entered terms that already exist into the free tag field
                form_set_error('taxonomy][tags]['.$vid, t('Tag(s) %dupes already exists in the vocabulary.', array('%dupes' => $terms)));
              }
            }
          }
        }
      }
    }
  }
}

function taxonomy_super_select_submit($form_id, $form_values){
  if($vid = $form_values['vid'] AND $form_id == 'taxonomy_form_vocabulary'){
    if(count($form_values['tss']['taxonomy_super_select_vid_'.$vid])){
      variable_set('taxonomy_super_select_vid_'.$form_values['vid'], $form_values['tss']['taxonomy_super_select_vid_'.$vid]);
    }
    else{
      variable_del('taxonomy_super_select_vid_'.$form_values['vid']);
    }
  }
}