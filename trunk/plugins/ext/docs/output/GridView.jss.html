<html><head><title>GridView.js</title><link rel="stylesheet" type="text/css" href="../resources/style.css" media="screen"/></head><body><h1>GridView.js</h1><pre class="highlighted"><code>Ext.grid.GridView = <b>function</b>(config){
    Ext.grid.GridView.superclass.constructor.call(<b>this</b>);
    <b>this</b>.el = null;

    Ext.apply(<b>this</b>, config);
};
Ext.extend(Ext.grid.GridView, Ext.grid.AbstractGridView, {
    rowClass : 'x-grid-row',
    
    cellClass : 'x-grid-col',

    tdClass : 'x-grid-td',

    hdClass : 'x-grid-hd',
    
    splitClass : 'x-grid-split',
    
    sortClasses : ['sort-asc', 'sort-desc'],
    
    enableMoveAnim : true,
    moveAnimColors : ['#dddddd', '#ebebeb', '#f1f1f1', ''],
    hlColor: 'C3DAF9',
    
    dh : Ext.DomHelper,
    
    fly : Ext.Element.fly,
    
    css : Ext.util.CSS,
    
    borderWidth: 1,
    
    splitOffset: 3,
    
    scrollIncrement : 22,
    
    cellRE: /(?:.*?)x-grid-(?:hd|cell|csplit)-(?:[\d]+)-([\d]+)(?:.*?)/,
    
    findRE: /\s?(?:x-grid-hd|x-grid-col|x-grid-csplit)\s/,
    
    init: <b>function</b>(grid){
		Ext.grid.GridView.superclass.init.call(<b>this</b>, grid);
		
		<b>this</b>.bind(grid.dataSource, grid.colModel);
		
	    grid.on('headerclick', <b>this</b>.handleHeaderClick, <b>this</b>);
	    
	    grid.cancelTextSelection = <b>function</b>(){};
		<b>this</b>.gridId = grid.id;
		
		<b>var</b> tpls = <b>this</b>.templates || {};
		
		<b>if</b>(!tpls.master){
		    tpls.master = <b>new</b> Ext.Template(
		       '&lt;div class=&quot;x-grid&quot; hidefocus=&quot;true&quot;&gt;',
		          '&lt;div class=&quot;x-grid-topbar&quot;&gt;&lt;/div&gt;',
		          '&lt;div class=&quot;x-grid-scroller&quot;&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;',
		          '&lt;div class=&quot;x-grid-locked&quot;&gt;',
		              '&lt;div class=&quot;x-grid-header&quot;&gt;{lockedHeader}&lt;/div&gt;',
		              '&lt;div class=&quot;x-grid-body&quot;&gt;{lockedBody}&lt;/div&gt;',
		          '&lt;/div&gt;',
		          '&lt;div class=&quot;x-grid-viewport&quot;&gt;',
		              '&lt;div class=&quot;x-grid-header&quot;&gt;{header}&lt;/div&gt;',
		              '&lt;div class=&quot;x-grid-body&quot;&gt;{body}&lt;/div&gt;',
		          '&lt;/div&gt;',
		          '&lt;div class=&quot;x-grid-bottombar&quot;&gt;&lt;/div&gt;',
		          '&lt;a href=&quot;#&quot; class=&quot;x-grid-focus&quot; tabIndex=&quot;-1&quot;&gt;&lt;/a&gt;',
		          '&lt;div class=&quot;x-grid-resize-proxy&quot;&gt;&amp;#160;&lt;/div&gt;',
		       '&lt;/div&gt;'
		    );
		    tpls.master.disableformats = true;
		}
		
		<b>if</b>(!tpls.header){
		    tpls.header = <b>new</b> Ext.Template(
		       '&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;',
		       '&lt;tbody&gt;&lt;tr class=&quot;x-grid-hd-row&quot;&gt;{cells}&lt;/tr&gt;&lt;/tbody&gt;',
		       '&lt;/table&gt;{splits}'
		    );
		    tpls.header.disableformats = true;
		}
		tpls.header.compile();
		
		<b>if</b>(!tpls.hcell){
		    tpls.hcell = <b>new</b> Ext.Template(
		        '&lt;td class=&quot;x-grid-hd x-grid-td-{id} {cellId}&quot;&gt;&lt;div title=&quot;{title}&quot; class=&quot;x-grid-hd-inner x-grid-hd-{id}&quot;&gt;',
		        '&lt;div class=&quot;x-grid-hd-text&quot; unselectable=&quot;on&quot;&gt;{value}&lt;img class=&quot;x-grid-sort-icon&quot; src=&quot;', Ext.BLANK_IMAGE_URL, '&quot; /&gt;&lt;/div&gt;',
		        '&lt;/div&gt;&lt;/td&gt;'
		     );
		     tpls.hcell.disableFormats = true;
		}
		tpls.hcell.compile();
		
		<b>if</b>(!tpls.hsplit){
		    tpls.hsplit = <b>new</b> Ext.Template('&lt;div class=&quot;x-grid-split {splitId} x-grid-split-{id}&quot; unselectable=&quot;on&quot;&gt;&amp;#160;&lt;/div&gt;');
		    tpls.hsplit.disableFormats = true;
		}
		tpls.hsplit.compile();
		
		<b>if</b>(!tpls.body){
		    tpls.body = <b>new</b> Ext.Template(
		       '&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;',
		       '&lt;tbody&gt;{rows}&lt;/tbody&gt;',
		       '&lt;/table&gt;'
		    );
		    tpls.body.disableFormats = true;
		}
		tpls.body.compile();
		
		<b>if</b>(!tpls.row){
		    tpls.row = <b>new</b> Ext.Template('&lt;tr class=&quot;x-grid-row {alt}&quot;&gt;{cells}&lt;/tr&gt;');
		    tpls.row.disableFormats = true;
		}
		tpls.row.compile();
		
		<b>if</b>(!tpls.cell){
		    tpls.cell = <b>new</b> Ext.Template(
		        '&lt;td class=&quot;x-grid-col x-grid-td-{id} {cellId} {css}&quot; tabIndex=&quot;0&quot;&gt;',
		        '&lt;div class=&quot;x-grid-col-{id} x-grid-cell-inner&quot;&gt;&lt;div class=&quot;x-grid-cell-text&quot; unselectable=&quot;on&quot; {attr}&gt;{value}&lt;/div&gt;&lt;/div&gt;',
		        '&lt;/td&gt;'
		    );
            tpls.cell.disableFormats = true;
        }
		tpls.cell.compile();
		
		<b>this</b>.templates = tpls;
	},
	
	bind : <b>function</b>(ds, cm){
        <b>if</b>(this.ds){
            <b>this</b>.ds.un('datachanged', <b>this</b>.onDataChange);
            <b>this</b>.ds.un('add', <b>this</b>.onAdd);
            <b>this</b>.ds.un('remove', <b>this</b>.onRemove);
            <b>this</b>.ds.un('update', <b>this</b>.onUpdate);
            <b>this</b>.ds.un('clear', <b>this</b>.onClear);
        }
        <b>if</b>(ds){
            ds.on('datachanged', <b>this</b>.onDataChange, <b>this</b>);
            ds.on('add', <b>this</b>.onAdd, <b>this</b>);
            ds.on('remove', <b>this</b>.onRemove, <b>this</b>);
            ds.on('update', <b>this</b>.onUpdate, <b>this</b>);
            ds.on('clear', <b>this</b>.onClear, <b>this</b>);
        }
        <b>this</b>.ds = ds;
        
        <b>if</b>(this.cm){
            <b>this</b>.cm.un('widthchange', <b>this</b>.updateColumns, <b>this</b>);
            <b>this</b>.cm.un('headerchange', <b>this</b>.updateHeaders, <b>this</b>);
            <b>this</b>.cm.un('hiddenchange', <b>this</b>.handleHiddenChange, <b>this</b>);
            <b>this</b>.cm.un('columnmoved', <b>this</b>.handleColumnMove, <b>this</b>);
            <b>this</b>.cm.un('columnlockchange', <b>this</b>.handleLockChange, <b>this</b>);
        }
        <b>if</b>(cm){
            <b>this</b>.generateRules(cm);
            cm.on('widthchange', <b>this</b>.updateColumns, <b>this</b>);
            cm.on('headerchange', <b>this</b>.updateHeaders, <b>this</b>);
            cm.on('hiddenchange', <b>this</b>.handleHiddenChange, <b>this</b>);
            cm.on('columnmoved', <b>this</b>.handleColumnMove, <b>this</b>);
            cm.on('columnlockchange', <b>this</b>.handleLockChange, <b>this</b>);
        }
        <b>this</b>.cm = cm;
    },
    
    onDataChange : <b>function</b>(){
        <b>this</b>.refresh();
        <b>this</b>.updateHeaderSortState();
    },

	onUpdate : <b>function</b>(ds, record){
        <b>var</b> index = <b>this</b>.ds.indexOf(record);
        <b>var</b> rows = <b>this</b>.getRowComposite(index);
        <b>var</b> cls = [];
        <b>this</b>.insertRows(ds, index, index, true);
        <b>this</b>.onDelete(ds, index+1, true);
        <b>this</b>.syncRowHeights(index, index);
        <b>this</b>.updateWrapHeight();
        <b>this</b>.fireEvent('rowupdated', <b>this</b>, index, record);
    },

    onAdd : <b>function</b>(ds, records, index){
        <b>this</b>.insertRows(ds, index, index + (records.length-1));
    },

    onDelete : <b>function</b>(ds, record, isUpdate){
        <b>var</b> index = <b>typeof</b> record == 'number' ? record : <b>this</b>.ds.indexOf(record);
        <b>if</b>(!isUpdate){
            <b>this</b>.fireEvent('beforerowsremoved', <b>this</b>, index, index);
        }
        <b>var</b> bt = <b>this</b>.getBodyTable(), lt = <b>this</b>.getLockedTable();
        <b>if</b>(bt.rows[index]){
            bt.firstChild.removeChild(bt.rows[index]);
        }
        <b>if</b>(lt.rows[index]){
            lt.firstChild.removeChild(lt.rows[index]);
        }
        <b>if</b>(!isUpdate){
            <b>this</b>.stripeRows(index);
            <b>this</b>.syncRowHeights(index, index);
            <b>this</b>.updateWrapHeight();
            <b>this</b>.fireEvent('rowsremoved', <b>this</b>, index, index);
        }
    },

    getHeaderPanel : <b>function</b>(){
	    <b>return</b> this.headerPanel;
	},
	
	getFooterPanel : <b>function</b>(){
	    <b>return</b> this.footerPanel;
	},
	
	initElements : <b>function</b>(){
	    <b>var</b> E = Ext.Element;
	    <b>var</b> el = <b>this</b>.grid.container.dom.firstChild;
	    <b>var</b> cs = el.childNodes;
	    
	    <b>this</b>.el = <b>new</b> E(el);
	    <b>this</b>.headerPanel = <b>new</b> E(el.firstChild);
	    <b>this</b>.headerPanel.enableDisplayMode('block');

        <b>this</b>.scroller = <b>new</b> E(cs[1]);
	    <b>this</b>.scrollSizer = <b>new</b> E(<b>this</b>.scroller.dom.firstChild);
	    
	    <b>this</b>.lockedWrap = <b>new</b> E(cs[2]);
	    <b>this</b>.lockedHd = <b>new</b> E(<b>this</b>.lockedWrap.dom.firstChild);
	    <b>this</b>.lockedBody = <b>new</b> E(<b>this</b>.lockedWrap.dom.childNodes[1]);
	    
	    <b>this</b>.mainWrap = <b>new</b> E(cs[3]);
	    <b>this</b>.mainHd = <b>new</b> E(<b>this</b>.mainWrap.dom.firstChild);
	    <b>this</b>.mainBody = <b>new</b> E(<b>this</b>.mainWrap.dom.childNodes[1]);
	    
	    <b>this</b>.footerPanel = <b>new</b> E(cs[4]);
	    <b>this</b>.footerPanel.enableDisplayMode('block');

        <b>this</b>.focusEl = <b>new</b> E(cs[5]);
        <b>this</b>.focusEl.swallowEvent('click', true);
        <b>this</b>.resizeProxy = <b>new</b> E(cs[6]);
	    
	    <b>this</b>.headerSelector = String.format(
	       '#{0} td.x-grid-hd, #{1} td.x-grid-hd',
	       <b>this</b>.lockedHd.id, <b>this</b>.mainHd.id
	    );
	    
	    <b>this</b>.splitterSelector = String.format(
	       '#{0} div.x-grid-split, #{1} div.x-grid-split',
	       <b>this</b>.lockedHd.id, <b>this</b>.mainHd.id
	    );
    },
	
	getHeaderCell : <b>function</b>(index){
	    <b>return</b> Ext.DomQuery.select(<b>this</b>.headerSelector)[index];
	},
	
	getHeaderCellMeasure : <b>function</b>(index){
	    <b>return</b> this.getHeaderCell(index).firstChild;
	},
	
	getHeaderCellText : <b>function</b>(index){
	    <b>return</b> this.getHeaderCell(index).firstChild.firstChild;
	},
	
	getLockedTable : <b>function</b>(){
	    <b>return</b> this.lockedBody.dom.firstChild;
	},
	
	getBodyTable : <b>function</b>(){
	    <b>return</b> this.mainBody.dom.firstChild;
	},
	
	getLockedRow : <b>function</b>(index){
	    <b>return</b> this.getLockedTable().rows[index];
	},
	
	getRow : <b>function</b>(index){
	    <b>return</b> this.getBodyTable().rows[index];
	},
	
	getRowComposite : <b>function</b>(index){
	    <b>if</b>(!<b>this</b>.rowEl){
	        <b>this</b>.rowEl = <b>new</b> Ext.CompositeElementLite();
	    }
        <b>var</b> els = [], lrow, mrow;
        <b>if</b>(lrow = <b>this</b>.getLockedRow(index)){
            els.push(lrow);
        }
        <b>if</b>(mrow = <b>this</b>.getRow(index)){
            els.push(mrow);
        }
        <b>this</b>.rowEl.elements = els;
	    <b>return</b> this.rowEl;
	},
	
	getCell : <b>function</b>(rowIndex, colIndex){
	    <b>var</b> locked = <b>this</b>.cm.getLockedCount();
	    <b>var</b> source;
	    <b>if</b>(colIndex &lt; locked){
	        source = <b>this</b>.lockedBody.dom.firstChild;
	    }<b>else</b>{
	        source = <b>this</b>.mainBody.dom.firstChild;
	        colIndex -= locked;
	    }
        <b>return</b> source.rows[rowIndex].childNodes[colIndex];
	},
	
	getCellText : <b>function</b>(rowIndex, colIndex){
	    <b>return</b> this.getCell(rowIndex, colIndex).firstChild.firstChild;
	},
	
	getCellBox : <b>function</b>(cell){
	    <b>var</b> b = <b>this</b>.fly(cell).getBox();
        <b>if</b>(Ext.isOpera){ <i>// opera fails to report the Y</i>
            b.y = cell.offsetTop + <b>this</b>.mainBody.getY();
        }
        <b>return</b> b;
    },
    
    getCellIndex : <b>function</b>(cell){
        <b>var</b> id = String(cell.className).match(<b>this</b>.cellRE);
        <b>if</b>(id){
            <b>return</b> parseInt(id[1], 10);
        }
        <b>return</b> 0;
    },
    
    findHeaderIndex : <b>function</b>(n){
        <b>var</b> r = Ext.fly(n).findParent('td.' + <b>this</b>.hdClass, 6);
        <b>return</b> r ? <b>this</b>.getCellIndex(r) : false;
    },
    
    findHeaderCell : <b>function</b>(n){
        <b>var</b> r = Ext.fly(n).findParent('td.' + <b>this</b>.hdClass, 6);
        <b>return</b> r ? r : false;
    },
    
    findRowIndex : <b>function</b>(n){
        <b>var</b> r = Ext.fly(n).findParent('tr.' + <b>this</b>.rowClass, 6);
        <b>return</b> r ? r.rowIndex : false;
    },
    
    findCellIndex : <b>function</b>(node){
        <b>var</b> stop = <b>this</b>.el.dom;
        <b>while</b>(node &amp;&amp; node != stop){
            <b>if</b>(this.findRE.test(node.className)){
                <b>return</b> this.getCellIndex(node);
            }
            node = node.parentNode;
        }
        <b>return</b> false;
    },
    
    getColumnId : <b>function</b>(index){
	    <b>return</b> this.cm.getColumnId(index);  
	},
	
	getSplitters : <b>function</b>(){
	    <b>if</b>(this.splitterSelector){
	       <b>return</b> Ext.DomQuery.select(<b>this</b>.splitterSelector);
	    }<b>else</b>{
	        <b>return</b> null;
	    }
	},
	
	getSplitter : <b>function</b>(index){
	    <b>return</b> this.getSplitters()[index];
	},
	
	renderHeaders : <b>function</b>(){
	    <b>var</b> cm = <b>this</b>.cm;
        <b>var</b> ct = <b>this</b>.templates.hcell, ht = <b>this</b>.templates.header, st = <b>this</b>.templates.hsplit;
        <b>var</b> cb = [], lb = [], sb = [], lsb = [], p = {};
        <b>for</b>(var i = 0, len = cm.getColumnCount(); i &lt; len; i++){
            p.cellId = 'x-grid-hd-0-' + i;
            p.splitId = 'x-grid-csplit-0-' + i;
            p.id = cm.getColumnId(i);
            p.title = cm.getColumnTooltip(i) || '';
            p.value = cm.getColumnHeader(i) || '';
            <b>if</b>(!cm.isLocked(i)){
                cb[cb.length] = ct.apply(p);
                sb[sb.length] = st.apply(p);
            }<b>else</b>{
                lb[lb.length] = ct.apply(p); 
                lsb[lsb.length] = st.apply(p);
            }
        }
        <b>return</b> [ht.apply({cells: lb.join(''), splits:lsb.join('')}), 
                ht.apply({cells: cb.join(''), splits:sb.join('')})];
	},
	
	updateHeaders : <b>function</b>(){
        <b>var</b> html = <b>this</b>.renderHeaders();
        <b>this</b>.lockedHd.update(html[0]);
        <b>this</b>.mainHd.update(html[1]);
    },
    
    <i>/**
     * Focuses the specified row..
     * @param {Number} row The row index
     */</i>
    focusRow : <b>function</b>(row){
        <b>var</b> x = <b>this</b>.scroller.dom.scrollLeft;
        <b>this</b>.focusCell(row, 0);
        <b>this</b>.scroller.dom.scrollLeft = x;
    },

    <i>/**
     * Focuses the specified cell.
     * @param {Number} row The row index
     * @param {Number} col The column index
     */</i>
    focusCell : <b>function</b>(row, col){
        <b>var</b> el = <b>this</b>.ensureVisible(row, col);
        <b>this</b>.focusEl.alignTo(el, 'tl-tl');
        <b>this</b>.focusEl.focus.defer(1, <b>this</b>.focusEl);
    },

    <i>/** @ignore */</i>
    ensureVisible : <b>function</b>(row, col){
        <b>if</b>(typeof row != 'number'){
            row = row.rowIndex;
        }
        <b>if</b>(row &lt; 0 &amp;&amp; row &gt;= <b>this</b>.ds.getCount()){
            <b>return</b>;
        }
        col = (col !== undefined ? col : 0);
        <b>var</b> cm = <b>this</b>.grid.colModel;
        <b>while</b>(cm.isHidden(col)){
            col++;
        }

        <b>var</b> el = <b>this</b>.getCell(row, col);
        <b>if</b>(!el){
            <b>return</b>;
        }
        <b>var</b> c = <b>this</b>.scroller.dom;
        
        <b>var</b> ctop = parseInt(el.offsetTop, 10);
        <b>var</b> cleft = parseInt(el.offsetLeft, 10);
        <b>var</b> cbot = ctop + el.offsetHeight;
        <b>var</b> cright = cleft + el.offsetWidth;

        <b>var</b> ch = c.clientHeight - <b>this</b>.mainHd.dom.offsetHeight;
        <b>var</b> stop = parseInt(c.scrollTop, 10);
        <b>var</b> sleft = parseInt(c.scrollLeft, 10);
        <b>var</b> sbot = stop + ch;
        <b>var</b> sright = sleft + c.clientWidth;

        <b>if</b>(ctop &lt; stop){
        	c.scrollTop = ctop;
        }<b>else</b> if(cbot &gt; sbot){
            c.scrollTop = cbot-ch;
        }

        <b>if</b>(cleft &lt; sleft){
        	c.scrollLeft = cleft;
        }<b>else</b> if(cright &gt; sright){
            c.scrollLeft = cright-c.clientWidth;
        }

        <b>return</b> el;
    },
    
    updateColumns : <b>function</b>(){
        <b>this</b>.grid.stopEditing();
        <b>var</b> cm = <b>this</b>.grid.colModel, colIds = <b>this</b>.getColumnIds();
        <i>//<b>var</b> totalWidth = cm.getTotalWidth();</i>
        <b>var</b> pos = 0;
        <b>for</b>(var i = 0, len = cm.getColumnCount(); i &lt; len; i++){
            <b>if</b>(cm.isHidden(i)) <b>continue</b>;
            <b>var</b> w = cm.getColumnWidth(i);
            <b>this</b>.css.updateRule(<b>this</b>.colSelector+colIds[i], 'width', (w - <b>this</b>.borderWidth) + 'px');
            <b>this</b>.css.updateRule(<b>this</b>.hdSelector+colIds[i], 'width', (w - <b>this</b>.borderWidth) + 'px');
        }
        <b>this</b>.updateSplitters();
    },
    
    updateSplitters : <b>function</b>(){
        <b>var</b> cm = <b>this</b>.cm, s = <b>this</b>.getSplitters();
        <b>if</b>(s){ <i>// splitters not created yet</i>
            <b>var</b> pos = 0, locked = true;
            <b>for</b>(var i = 0, len = cm.getColumnCount(); i &lt; len; i++){
                <b>if</b>(cm.isHidden(i)) <b>continue</b>;
                <b>var</b> w = cm.getColumnWidth(i);
                <b>if</b>(!cm.isLocked(i) &amp;&amp; locked){
                    pos = 0;
                    locked = false;
                }
                pos += w;
                s[i].style.left = (pos-<b>this</b>.splitOffset) + 'px';
            }
        }
    },
    
    handleHiddenChange : <b>function</b>(colModel, colIndex, hidden){
        <b>if</b>(hidden){
            <b>this</b>.hideColumn(colIndex);
        }<b>else</b>{
            <b>this</b>.unhideColumn(colIndex);
        }
    },
    
    hideColumn : <b>function</b>(colIndex){
        <b>var</b> cid = <b>this</b>.getColumnId(colIndex);
        <b>this</b>.css.updateRule(<b>this</b>.tdSelector+cid, 'display', 'none');
        <b>this</b>.css.updateRule(<b>this</b>.splitSelector+cid, 'display', 'none');
        <b>if</b>(Ext.isSafari){
            <b>this</b>.updateHeaders();
        }
        <b>this</b>.updateSplitters();
        <b>this</b>.updateWrapHeight();
    },
    
    unhideColumn : <b>function</b>(colIndex){
        <b>var</b> cid = <b>this</b>.getColumnId(colIndex);
        <b>this</b>.css.updateRule(<b>this</b>.tdSelector+cid, 'display', '');
        <b>this</b>.css.updateRule(<b>this</b>.splitSelector+cid, 'display', '');
        <b>if</b>(Ext.isSafari){
            <b>this</b>.updateHeaders();
        }
        <b>this</b>.updateSplitters();
        <b>this</b>.updateWrapHeight();
    },
    
    insertRows : <b>function</b>(dm, firstRow, lastRow, isUpdate){
        <b>if</b>(firstRow == 0 &amp;&amp; lastRow == dm.getCount()-1){
            <b>this</b>.refresh();
        }<b>else</b>{
            <b>if</b>(!isUpdate){
                <b>this</b>.fireEvent('beforerowsinserted', <b>this</b>, firstRow, lastRow);
            }
            <b>var</b> s = <b>this</b>.getScrollState();
            <b>var</b> markup = <b>this</b>.renderRows(firstRow, lastRow);
            <b>this</b>.bufferRows(markup[0], <b>this</b>.getLockedTable(), firstRow);
            <b>this</b>.bufferRows(markup[1], <b>this</b>.getBodyTable(), firstRow);
            <b>this</b>.restoreScroll(s);
            <b>if</b>(!isUpdate){
                <b>this</b>.fireEvent('rowsinserted', <b>this</b>, firstRow, lastRow);
                <b>this</b>.syncRowHeights(firstRow, lastRow);
                <b>this</b>.updateWrapHeight();
            }
        }
    },
    
    bufferRows : <b>function</b>(markup, target, index){
        <b>var</b> before = null, trows = target.rows, tbody = target.tBodies[0];
        <b>if</b>(index &lt; trows.length){
            before = trows[index];
        }
        <b>var</b> b = document.createElement('div');
        b.innerHTML = '&lt;table&gt;&lt;tbody&gt;'+markup+'&lt;/tbody&gt;&lt;/table&gt;';  
        <b>var</b> rows = b.firstChild.rows;
        <b>for</b>(var i = 0, len = rows.length; i &lt; len; i++){
            <b>if</b>(before){
                tbody.insertBefore(rows[i], before);
            }<b>else</b>{
                tbody.appendChild(rows[i]);
            }
        }                
        b.innerHTML = '';
        b = null;
    },
    
    deleteRows : <b>function</b>(dm, firstRow, lastRow){
        <b>if</b>(dm.getRowCount()&lt;1){
            <b>this</b>.fireEvent('beforerefresh', <b>this</b>);
            <b>this</b>.mainBody.update('');
            <b>this</b>.lockedBody.update('');
            <b>this</b>.fireEvent('refresh', <b>this</b>);
        }<b>else</b>{
            <b>this</b>.fireEvent('beforerowsdeleted', <b>this</b>, firstRow, lastRow);
            <b>var</b> bt = <b>this</b>.getBodyTable();
            <b>var</b> tbody = bt.firstChild;
            <b>var</b> rows = bt.rows;
            <b>for</b>(var rowIndex = firstRow; rowIndex &lt;= lastRow; rowIndex++){
                tbody.removeChild(rows[firstRow]);
            }
            <b>this</b>.stripeRows(firstRow);
            <b>this</b>.fireEvent('rowsdeleted', <b>this</b>, firstRow, lastRow);
        }
    },
    
    updateRows : <b>function</b>(dataSource, firstRow, lastRow){
        <b>var</b> s = <b>this</b>.getScrollState();
        <b>this</b>.refresh();
        <b>this</b>.restoreScroll(s);
    },
    
    handleSort : <b>function</b>(dataSource, sortColumnIndex, sortDir, noRefresh){
        <b>if</b>(!noRefresh){
           <b>this</b>.refresh();
        }
        <b>this</b>.updateHeaderSortState();
    },
    
    getScrollState : <b>function</b>(){
        <b>var</b> sb = <b>this</b>.scroller.dom;
        <b>return</b> {left: sb.scrollLeft, top: sb.scrollTop};
    },
    
    stripeRows : <b>function</b>(startRow){
        <b>if</b>(!<b>this</b>.grid.stripeRows){
            <b>return</b>;
        }
        startRow = startRow || 0;
        <b>var</b> rows = <b>this</b>.getBodyTable().rows;
        <b>var</b> lrows = <b>this</b>.getLockedTable().rows;
        <b>var</b> re = /x-grid-row-alt/g;
        <b>for</b>(var i = startRow, len = rows.length; i &lt;= len; i++){
            <b>var</b> row = rows[i], lrow = lrows[i];
            <b>var</b> isAlt = ((i+1) % 2 == 0);
            <b>var</b> hasAlt = re.test(row.className);
            <b>if</b>(isAlt == hasAlt){
                <b>continue</b>;
            }
            <b>if</b>(isAlt){
                row.className += ' x-grid-row-alt';
            }<b>else</b>{
                row.className = row.className.replace(re, '');
            }
            lrow.className = row.className;
        }
    },
    
    restoreScroll : <b>function</b>(state){
        <b>var</b> sb = <b>this</b>.scroller.dom;
        sb.scrollLeft = state.left;
        sb.scrollTop = state.top;
        <b>this</b>.syncScroll();
    },
    
    syncScroll : <b>function</b>(){
        <b>var</b> sb = <b>this</b>.scroller.dom;
        <b>var</b> sh = <b>this</b>.mainHd.dom;
        <b>var</b> bs = <b>this</b>.mainBody.dom;
        <b>var</b> lv = <b>this</b>.lockedBody.dom;
        sh.scrollLeft = bs.scrollLeft = sb.scrollLeft;
        lv.scrollTop = bs.scrollTop = sb.scrollTop;
    },
    
    handleScroll : <b>function</b>(e){
        <b>this</b>.syncScroll();
        <b>var</b> sb = <b>this</b>.scroller.dom;
        <b>this</b>.grid.fireEvent('bodyscroll', sb.scrollLeft, sb.scrollTop);
        e.stopEvent();
    },
    
    handleWheel : <b>function</b>(e){
        <b>var</b> d = e.getWheelDelta();
        <b>this</b>.scroller.dom.scrollTop -= d*22;
        <i>// set <b>this</b> here to prevent jumpy scrolling on large tables</i>
        <b>this</b>.lockedBody.dom.scrollTop = <b>this</b>.mainBody.dom.scrollTop = <b>this</b>.scroller.dom.scrollTop;
        e.stopEvent();
    },
    
    renderRows : <b>function</b>(startRow, endRow){
        <i>// pull <b>in</b> all the crap needed to render rows</i>
        <b>var</b> g = <b>this</b>.grid, cm = g.colModel, ds = g.dataSource, stripe = g.stripeRows;
        <b>var</b> colCount = cm.getColumnCount();
        
        <b>if</b>(ds.getCount() &lt; 1){
            <b>return</b> ['', ''];
        }
        
        <i>// build a map <b>for</b> all the columns</i>
        <b>var</b> cs = [];
        <b>for</b>(var i = 0; i &lt; colCount; i++){
            cs[i] = {
                name : cm.getDataIndex(i) || ds.fields.get(i).name,
                renderer : cm.getRenderer(i),
                id : cm.getColumnId(i),
                locked : cm.isLocked(i)
            };
        }
                
        startRow = startRow || 0;
        endRow = <b>typeof</b> endRow == 'undefined'? ds.getCount()-1 : endRow;
        
        <i>// records to render</i>
        <b>var</b> rs = ds.getRange(startRow, endRow);

        <b>return</b> this.doRender(cs, rs, ds, startRow, colCount, stripe);
    },

    <i>// As much as I hate to duplicate code, <b>this</b> was branched because FireFox really hates</i>
    <i>// [].join('') on strings. The performance difference was substantial enough to</i>
    <i>// branch <b>this</b> function</i>
    doRender : Ext.isGecko ?
            <b>function</b>(cs, rs, ds, startRow, colCount, stripe){
                <b>var</b> ts = <b>this</b>.templates, ct = ts.cell, rt = ts.row;
                <i>// buffers</i>
                <b>var</b> buf = '', lbuf = '', cb, lcb, c, p = {}, rp = {}, r;
                <b>for</b>(var j = 0, len = rs.length; j &lt; len; j++){
                    r = rs[j], cb = '', lcb = '', rowIndex = (j+startRow);
                    <b>for</b>(var i = 0; i &lt; colCount; i++){
                        c = cs[i];
                        p.cellId = 'x-grid-cell-' + rowIndex + '-' + i;
                        p.id = c.id;
                        p.css = p.attr = '';
                        p.value = c.renderer(r.data[c.name], p, r, rowIndex, i, ds);
                        <b>if</b>(p.value == undefined || p.value === '') p.value = '&amp;#160;';
                        <b>var</b> markup = ct.apply(p);
                        <b>if</b>(!c.locked){
                            cb+= markup;
                        }<b>else</b>{
                            lcb+= markup;
                        }
                    }
                    <b>var</b> alt = '';
                    <b>if</b>(stripe &amp;&amp; ((rowIndex+1) % 2 == 0)){
                        alt = 'x-grid-row-alt';
                    }
                    rp.cells = lcb;
                    rp.alt = alt;
                    lbuf+= rt.apply(rp);
                    rp.cells = cb;
                    buf+=  rt.apply(rp);
                }
                <b>return</b> [lbuf, buf];
            } :
            <b>function</b>(cs, rs, ds, startRow, colCount, stripe){
                <b>var</b> ts = <b>this</b>.templates, ct = ts.cell, rt = ts.row;
                <i>// buffers</i>
                <b>var</b> buf = [], lbuf = [], cb, lcb, c, p = {}, rp = {}, r;
                <b>for</b>(var j = 0, len = rs.length; j &lt; len; j++){
                    r = rs[j], cb = [], lcb = [], rowIndex = (j+startRow);
                    <b>for</b>(var i = 0; i &lt; colCount; i++){
                        c = cs[i];
                        p.cellId = 'x-grid-cell-' + rowIndex + '-' + i;
                        p.id = c.id;
                        p.css = p.attr = '';
                        p.value = c.renderer(r.data[c.name], p, r, rowIndex, i, ds);
                        <b>if</b>(p.value == undefined || p.value === '') p.value = '&amp;#160;';
                        <b>var</b> markup = ct.apply(p);
                        <b>if</b>(!c.locked){
                            cb[cb.length] = markup;
                        }<b>else</b>{
                            lcb[lcb.length] = markup;
                        }
                    }
                    <b>var</b> alt = '';
                    <b>if</b>(stripe &amp;&amp; ((rowIndex+1) % 2 == 0)){
                        alt = 'x-grid-row-alt';
                    }
                    rp.cells = lcb.join('');
                    rp.alt = alt;
                    lbuf[lbuf.length] = rt.apply(rp);
                    rp.cells = cb.join('');
                    buf[buf.length] =  rt.apply(rp);
                }
                <b>return</b> [lbuf.join(''), buf.join('')];
            },

    renderBody : <b>function</b>(){
        <b>var</b> markup = <b>this</b>.renderRows();
        <b>var</b> bt = <b>this</b>.templates.body;
        <b>return</b> [bt.apply({rows: markup[0]}), bt.apply({rows: markup[1]})];
    },
    
    refresh : <b>function</b>(headersToo){
        <b>this</b>.fireEvent('beforerefresh', <b>this</b>);
        <b>this</b>.grid.stopEditing();
        <b>var</b> result = <b>this</b>.renderBody();
        <b>this</b>.lockedBody.update(result[0]);
        <b>this</b>.mainBody.update(result[1]);
        <b>if</b>(headersToo === true){
            <b>this</b>.updateHeaders();
            <b>this</b>.updateColumns();
            <b>this</b>.updateSplitters();
            <b>this</b>.updateHeaderSortState();
        }
        <b>this</b>.syncRowHeights();
        <b>this</b>.updateWrapHeight();
        <b>this</b>.fireEvent('refresh', <b>this</b>);
    },
    
    handleColumnMove : <b>function</b>(cm, oldIndex, newIndex){
        <b>this</b>.indexMap = null;
        <b>var</b> s = <b>this</b>.getScrollState();
        <b>this</b>.refresh(true);
        <b>this</b>.restoreScroll(s);
        <b>this</b>.afterMove(newIndex);
    },
    
    afterMove : <b>function</b>(colIndex){
        <b>if</b>(this.enableMoveAnim &amp;&amp; Ext.enableFx){
            <b>this</b>.fly(<b>this</b>.getHeaderCell(colIndex).firstChild).highlight(<b>this</b>.hlColor);
        }
    },
    
    updateCell : <b>function</b>(dm, rowIndex, dataIndex){
        <b>var</b> colIndex = <b>this</b>.getColumnIndexByDataIndex(dataIndex);
        <b>if</b>(typeof colIndex == 'undefined'){ <i>// not present <b>in</b> grid</i>
            <b>return</b>;
        }
        <b>var</b> cm = <b>this</b>.grid.colModel;
        <b>var</b> cell = <b>this</b>.getCell(rowIndex, colIndex);
        <b>var</b> cellText = <b>this</b>.getCellText(rowIndex, colIndex);
        
        <b>var</b> p = {
            cellId : 'x-grid-cell-' + rowIndex + '-' + colIndex,
            id : cm.getColumnId(colIndex),
            css: colIndex == cm.getColumnCount()-1 ? 'x-grid-col-last' : ''
        };
        <b>var</b> renderer = cm.getRenderer(colIndex);
        <b>var</b> val = renderer(dm.getValueAt(rowIndex, dataIndex), p, rowIndex, colIndex, dm);
        <b>if</b>(typeof val == 'undefined' || val === '') val = '&amp;#160;';
        cellText.innerHTML = val;
        cell.className = <b>this</b>.cellClass + ' ' + p.cellId + ' ' + p.css;
        <b>this</b>.syncRowHeights(rowIndex, rowIndex);
    },
    
    calcColumnWidth : <b>function</b>(colIndex, maxRowsToMeasure){
        <b>var</b> maxWidth = 0;
        <b>var</b> rows = (<b>this</b>.cm.isLocked(colIndex) ? <b>this</b>.getLockedTable() : <b>this</b>.getBodyTable()).rows;
        <b>var</b> stopIndex = Math.min(maxRowsToMeasure || rows.length, rows.length);
        <b>if</b>(this.grid.autoSizeHeaders){
            <b>var</b> h = <b>this</b>.getHeaderCellMeasure(colIndex);
            maxWidth = Math.max(maxWidth, h.scrollWidth);
        }
        <b>for</b>(var i = 0; i &lt; stopIndex; i++){
            <b>var</b> cell = rows[i].childNodes[colIndex].firstChild;
            maxWidth = Math.max(maxWidth, cell.scrollWidth);
        }
        <b>return</b> maxWidth + <i>/*margin <b>for</b> error <b>in</b> IE*/</i> 5;
    },
    <i>/**
     * Autofit a column to its content.
     * @param {Number} colIndex
     * @param {Boolean} forceMinSize true to force the column to go smaller <b>if</b> possible
     */</i>
     autoSizeColumn : <b>function</b>(colIndex, forceMinSize, suppressEvent){
         <b>if</b>(this.cm.isHidden(colIndex)){
             <b>return</b>; <i>// can't calc a hidden column</i>
         }
        <b>if</b>(forceMinSize){
           <b>this</b>.css.updateRule(<b>this</b>.colSelector + colIndex, 'width', <b>this</b>.grid.minColumnWidth + 'px');
           <b>if</b>(this.grid.autoSizeHeaders){
               <b>this</b>.css.updateRule(<b>this</b>.hdSelector + colIndex, 'width', <b>this</b>.grid.minColumnWidth + 'px');
           }
        }
        <b>var</b> newWidth = <b>this</b>.calcColumnWidth(colIndex);
        <b>this</b>.cm.setColumnWidth(colIndex,
            Math.max(<b>this</b>.grid.minColumnWidth, newWidth), suppressEvent);
        <b>if</b>(!suppressEvent){
            <b>this</b>.grid.fireEvent('columnresize', colIndex, newWidth);
        }
    },
    
    <i>/**
     * Autofits all columns to their content and then expands to fit any extra space <b>in</b> the grid
     */</i>
     autoSizeColumns : <b>function</b>(){
        <b>var</b> cm = <b>this</b>.grid.colModel;
        <b>var</b> colCount = cm.getColumnCount();
        <b>for</b>(var i = 0; i &lt; colCount; i++){
            <b>this</b>.autoSizeColumn(i, true, true);
        }
        <b>if</b>(cm.getTotalWidth() &lt; <b>this</b>.getScrollBody().clientWidth){
            <b>this</b>.fitColumns();
        }<b>else</b>{
            <b>this</b>.updateColumns(); 
        } 
    },
    
    <i>/**
     * Autofits all columns to the grid's width proportionate <b>with</b> their current size
     * @param {Boolean} reserveScrollSpace Reserve space <b>for</b> a scrollbar
     */</i>
    fitColumns : <b>function</b>(reserveScrollSpace){
        <b>var</b> cm = <b>this</b>.grid.colModel;
        <b>var</b> colCount = cm.getColumnCount();
        <b>var</b> cols = [];
        <b>var</b> width = 0;
        <b>var</b> i, w;
        <b>for</b> (i = 0; i &lt; colCount; i++){
            <b>if</b>(!cm.isHidden(i) &amp;&amp; !cm.isFixed(i)){
                w = cm.getColumnWidth(i);
                cols.push(i);
                cols.push(w);
                width += w;
            }
        }
        <b>var</b> avail = Math.min(<b>this</b>.scroller.dom.clientWidth, <b>this</b>.el.getWidth());
        <b>if</b>(reserveScrollSpace){
            avail -= 17;
        }
        <b>var</b> frac = (avail - cm.getTotalWidth())/width;
        <b>while</b> (cols.length){
            w = cols.pop();
            i = cols.pop();
            cm.setColumnWidth(i, Math.floor(w + w*frac), true);
        }
        <b>this</b>.updateColumns();
        <b>this</b>.updateWrapHeight();
    }, 
    
    onRowSelect : <b>function</b>(rowIndex){
        <b>var</b> row = <b>this</b>.getRowComposite(rowIndex);
        row.addClass('x-grid-row-selected');
    },

    onRowDeselect : <b>function</b>(rowIndex){
        <b>var</b> row = <b>this</b>.getRowComposite(rowIndex);
        row.removeClass('x-grid-row-selected');
    },

    onCellSelect : <b>function</b>(row, col){
        <b>var</b> cell = <b>this</b>.getCell(row, col);
        <b>if</b>(cell){
            Ext.fly(cell).addClass('x-grid-cell-selected');
        }
    },

    onCellDeselect : <b>function</b>(row, col){
        <b>var</b> cell = <b>this</b>.getCell(row, col);
        <b>if</b>(cell){
            Ext.fly(cell).removeClass('x-grid-cell-selected');
        }
    },

    updateHeaderSortState : <b>function</b>(){
        <b>var</b> state = <b>this</b>.ds.getSortState();
        <b>if</b>(!state){
            <b>return</b>;
        }
        <b>this</b>.sortState = state;
        <b>var</b> sortColumn = <b>this</b>.cm.findColumnIndex(state.field);
        <b>if</b>(sortColumn != -1){
            <b>var</b> sortDir = state.direction;
            <b>var</b> sc = <b>this</b>.sortClasses;
            <b>var</b> hds = <b>this</b>.el.select(<b>this</b>.headerSelector).removeClass(sc);
            hds.item(sortColumn).addClass(sc[sortDir == 'DESC' ? 1 : 0]);
        }
    },
    
    handleHeaderClick : <b>function</b>(g, index){
        <b>if</b>(this.headersDisabled){
            <b>return</b>;
        }
        <b>var</b> dm = g.dataSource, cm = g.colModel;
	    <b>if</b>(!cm.isSortable(index)){
            <b>return</b>;
        }
	    g.stopEditing();
        dm.sort(cm.getDataIndex(index));
    },
    
    
    destroy : <b>function</b>(){
        <b>this</b>.bind(null, null);
    },
    
    handleLockChange : <b>function</b>(){
        <b>this</b>.refresh(true);  
    },

    handleHdMenuClick : <b>function</b>(item){
        <b>var</b> index = <b>this</b>.hdCtxIndex;
        <b>var</b> cm = <b>this</b>.cm, ds = <b>this</b>.ds;
        <b>switch</b>(item.id){
            <b>case</b> 'asc':
                ds.sort(cm.getDataIndex(index), 'ASC');
                <b>break</b>;
            <b>case</b> 'desc':
                ds.sort(cm.getDataIndex(index), 'DESC');
                <b>break</b>;
            <b>case</b> 'lock':
                <b>var</b> lc = cm.getLockedCount();
                <b>if</b>(lc != index){
                    cm.setLocked(index, true, true);
                    cm.moveColumn(index, lc);
                    <b>this</b>.grid.fireEvent('columnmove', index, lc);
                }<b>else</b>{
                    cm.setLocked(index, true);
                }
            <b>break</b>;
            <b>case</b> 'unlock':
                <b>var</b> lc = cm.getLockedCount();
                <b>if</b>((lc-1) != index){
                    cm.setLocked(index, false, true);
                    cm.moveColumn(index, lc-1);
                    <b>this</b>.grid.fireEvent('columnmove', index, lc-1);
                }<b>else</b>{
                    cm.setLocked(index, false);
                }
            <b>break</b>;
            <b>default</b>:
                index = cm.getIndexById(item.id.substr(4));
                <b>if</b>(index != -1){
                    cm.setHidden(index, item.checked);
                }
        }
        <b>return</b> true;
    },

    beforeColMenuShow : <b>function</b>(){
        <b>var</b> cm = <b>this</b>.cm,  colCount = cm.getColumnCount();
        <b>this</b>.colMenu.removeAll();
        <b>for</b>(var i = 0; i &lt; colCount; i++){
            <b>this</b>.colMenu.add(<b>new</b> Ext.menu.CheckItem({
                id: 'col-'+cm.getColumnId(i),
                text: cm.getColumnHeader(i),
                checked: !cm.isHidden(i),
                hideOnClick:false
            }));
        }
    },

    handleHdCtx : <b>function</b>(g, index, e){
        e.stopEvent();
        <b>var</b> hd = <b>this</b>.getHeaderCell(index);
        <b>this</b>.hdCtxIndex = index;
        <b>var</b> ms = <b>this</b>.hmenu.items, cm = <b>this</b>.cm;
        ms.get('asc').setDisabled(!cm.isSortable(index));
        ms.get('desc').setDisabled(!cm.isSortable(index));
        <b>if</b>(this.grid.enableColLock !== false){
            ms.get('lock').setDisabled(cm.isLocked(index));
            ms.get('unlock').setDisabled(!cm.isLocked(index));
        }
        <b>this</b>.hmenu.show(hd, 'tl-bl');
    },

    handleHdOver : <b>function</b>(e){
        <b>var</b> hd = <b>this</b>.findHeaderCell(e.getTarget());
        <b>if</b>(hd &amp;&amp; !<b>this</b>.headersDisabled){
            <b>if</b>(this.grid.colModel.isSortable(<b>this</b>.getCellIndex(hd))){
               <b>this</b>.fly(hd).addClass('x-grid-hd-over');
            }
        }
    },
    
    handleHdOut : <b>function</b>(e){
        <b>var</b> hd = <b>this</b>.findHeaderCell(e.getTarget());
        <b>if</b>(hd){
            <b>this</b>.fly(hd).removeClass('x-grid-hd-over');
        }
    },

    handleSplitDblClick : <b>function</b>(e, t){
        <b>var</b> i = <b>this</b>.getCellIndex(t);
        <b>this</b>.autoSizeColumn(i, true);
    },

    render : <b>function</b>(){
        
        <b>var</b> cm = <b>this</b>.cm;
        <b>var</b> colCount = cm.getColumnCount();
        
        <b>if</b>(this.grid.monitorWindowResize === true){
            Ext.EventManager.onWindowResize(<b>this</b>.onWindowResize, <b>this</b>, true);
        }
        
        <b>var</b> header = <b>this</b>.renderHeaders();
        <b>var</b> body = <b>this</b>.templates.body.apply({rows:''});
        <b>var</b> html = <b>this</b>.templates.master.apply({
            lockedBody: body,
            body: body,
            lockedHeader: header[0],
            header: header[1]
        });
        
        <b>this</b>.updateColumns();

        <b>this</b>.grid.container.dom.innerHTML = html;

        <b>this</b>.initElements();

        <b>this</b>.scroller.on('scroll', <b>this</b>.handleScroll, <b>this</b>);
        <b>this</b>.lockedBody.on('mousewheel', <b>this</b>.handleWheel, <b>this</b>);
        <b>this</b>.mainBody.on('mousewheel', <b>this</b>.handleWheel, <b>this</b>);
        
        <b>this</b>.mainHd.on('mouseover', <b>this</b>.handleHdOver, <b>this</b>);
        <b>this</b>.mainHd.on('mouseout', <b>this</b>.handleHdOut, <b>this</b>);
        <b>this</b>.mainHd.on('dblclick', <b>this</b>.handleSplitDblClick, <b>this</b>,
                {delegate: '.'+<b>this</b>.splitClass});

        <b>this</b>.lockedHd.on('mouseover', <b>this</b>.handleHdOver, <b>this</b>);
        <b>this</b>.lockedHd.on('mouseout', <b>this</b>.handleHdOut, <b>this</b>);
        <b>this</b>.lockedHd.on('dblclick', <b>this</b>.handleSplitDblClick, <b>this</b>,
                {delegate: '.'+<b>this</b>.splitClass});

        <b>if</b>(this.grid.enableColumnResize !== false){
            <b>new</b> Ext.grid.SplitDragZone(<b>this</b>.grid, <b>this</b>.lockedHd.dom, <b>this</b>.mainHd.dom);
        }

        <b>this</b>.updateSplitters();

        <b>if</b>(this.grid.enableColumnMove){
            <b>new</b> Ext.grid.HeaderDragZone(<b>this</b>.grid, <b>this</b>.lockedHd.dom, <b>this</b>.mainHd.dom);
            <b>new</b> Ext.grid.HeaderDropZone(<b>this</b>.grid, <b>this</b>.lockedHd.dom, <b>this</b>.mainHd.dom);
        }

        <b>if</b>(this.grid.enableCtxMenu !== false){
            <b>this</b>.colMenu = <b>new</b> Ext.menu.Menu({id:<b>this</b>.grid.id + '-hcols-menu'});
            <b>this</b>.colMenu.on('beforeshow', <b>this</b>.beforeColMenuShow, <b>this</b>);
            <b>this</b>.colMenu.on('itemclick', <b>this</b>.handleHdMenuClick, <b>this</b>);

            <b>this</b>.hmenu = <b>new</b> Ext.menu.Menu({id: <b>this</b>.grid.id + '-hctx'});
            <b>this</b>.hmenu.add(
                {id:'asc', text: <b>this</b>.sortAscText, cls: 'xg-hmenu-sort-asc'},
                {id:'desc', text: <b>this</b>.sortDescText, cls: 'xg-hmenu-sort-desc'},
                'separator'
            );
            <b>if</b>(this.grid.enableColLock !== false){
                <b>this</b>.hmenu.add(
                    {id:'lock', text: <b>this</b>.lockText, cls: 'xg-hmenu-lock'},
                    {id:'unlock', text: <b>this</b>.unlockText, cls: 'xg-hmenu-unlock'},
                    'separator'
                );
            }
            <b>this</b>.hmenu.add(
                {id:'columns', text: <b>this</b>.columnsText, menu: <b>this</b>.colMenu}
            );
            <b>this</b>.hmenu.on('itemclick', <b>this</b>.handleHdMenuClick, <b>this</b>);

            <b>this</b>.grid.on('headercontextmenu', <b>this</b>.handleHdCtx, <b>this</b>);
        }

        <b>if</b>(this.grid.autoSizeColumns){
            <b>this</b>.autoSizeColumns();
        }

        <b>for</b>(var i = 0; i &lt; colCount; i++){
            <b>if</b>(cm.isHidden(i)){
                <b>this</b>.hideColumn(i);
            }
            <b>if</b>(cm.config[i].align){
                <b>this</b>.css.updateRule(<b>this</b>.colSelector + i, 'textAlign', cm.config[i].align);
                <b>this</b>.css.updateRule(<b>this</b>.hdSelector + i, 'textAlign', cm.config[i].align);
            }
        }
        
        <b>this</b>.updateHeaderSortState();
        
        <b>this</b>.beforeInitialResize();
        <b>this</b>.updateWrapHeight(true);

        <i>// two part rendering gives faster view to the user</i>
        <b>this</b>.renderPhase2.defer(1, <b>this</b>);
    },

    renderPhase2 : <b>function</b>(){
        <i>// render the rows now</i>
        <b>this</b>.refresh();
    },

    beforeInitialResize : <b>function</b>(){
        
    },
    
    onColumnSplitterMoved : <b>function</b>(i, w){
        <b>var</b> cm = <b>this</b>.grid.colModel;
        cm.setColumnWidth(i, w, true);
        <b>var</b> cid = cm.getColumnId(i);
        <b>this</b>.css.updateRule(<b>this</b>.colSelector + cid, 'width', (w-<b>this</b>.borderWidth) + 'px');
        <b>this</b>.css.updateRule(<b>this</b>.hdSelector + cid, 'width', (w-<b>this</b>.borderWidth) + 'px');
        <b>this</b>.updateSplitters();
        <b>this</b>.updateWrapHeight();
        <b>this</b>.grid.fireEvent('columnresize', i, w);
    },
    
    syncRowHeights : <b>function</b>(startIndex, endIndex){
        <b>if</b>(this.grid.enableRowHeightSync === true &amp;&amp; <b>this</b>.cm.getLockedCount() &gt; 0){
            startIndex = startIndex || 0;
            <b>var</b> mrows = <b>this</b>.getBodyTable().rows;
            <b>var</b> lrows = <b>this</b>.getLockedTable().rows;
            <b>var</b> len = mrows.length-1;
            endIndex = Math.min(endIndex || len, len);
            <b>for</b>(var i = startIndex; i &lt;= endIndex; i++){
                <b>var</b> m = mrows[i], l = lrows[i];
                <b>var</b> h = Math.max(m.offsetHeight, l.offsetHeight);
                m.style.height = l.style.height = h + 'px';
            }
        }
    },
    
    updateWrapHeight : <b>function</b>(initialRender){
        <b>var</b> auto = <b>this</b>.grid.autoHeight;
        <b>var</b> scrollOffset = 16;
        <b>var</b> c = <b>this</b>.grid.container;
        c.beginMeasure();

        <i>// required <b>for</b> ie</i>
        <b>var</b> tbh = <b>this</b>.headerPanel.getHeight();
        <b>var</b> bbh = <b>this</b>.footerPanel.getHeight();

        <b>if</b>(auto){
            <b>var</b> ch = <b>this</b>.getBodyTable().offsetHeight + tbh + bbh + <b>this</b>.mainHd.getHeight();
            c.setHeight(ch+c.getBorderWidth('tb'));
        }

        <b>var</b> s = <b>this</b>.scroller;

        <b>var</b> csize = c.getSize(true);

        <b>this</b>.el.setSize(csize.width, csize.height);

        <b>this</b>.headerPanel.setWidth(csize.width);
        <b>this</b>.footerPanel.setWidth(csize.width);

        <b>var</b> hdHeight = <b>this</b>.mainHd.getHeight();
        <b>var</b> vw = csize.width;
        <b>var</b> vh = csize.height - (tbh + bbh);

        s.setSize(vw, vh);

        <b>var</b> bt = <b>this</b>.getBodyTable();
        <b>var</b> ltWidth = Math.max(<b>this</b>.getLockedTable().offsetWidth, <b>this</b>.lockedHd.dom.firstChild.offsetWidth);

        <b>var</b> scrollHeight = bt.offsetHeight;
        <b>var</b> scrollWidth = ltWidth + bt.offsetWidth;
        <b>var</b> vscroll = false, hscroll = false;

        <b>this</b>.scrollSizer.setSize(scrollWidth, scrollHeight+hdHeight);

        <b>var</b> lw = <b>this</b>.lockedWrap, mw = <b>this</b>.mainWrap;
        <b>var</b> lb = <b>this</b>.lockedBody, mb = <b>this</b>.mainBody;

        setTimeout(<b>function</b>(){
            <b>var</b> t = s.dom.offsetTop;
            <b>var</b> w = s.dom.clientWidth, 
                h = auto ? s.dom.offsetHeight : s.dom.clientHeight;
            
            lw.setTop(t);
            lw.setSize(ltWidth, h);
            
            mw.setLeftTop(ltWidth, t);
            mw.setSize(w-ltWidth, h);
            
            lb.setHeight(h-hdHeight);
            mb.setHeight(h-hdHeight);
            
            <b>if</b>(initialRender){
                lw.show();
                mw.show();
            }
            c.endMeasure();
        }, 10);
    },
    
    onWindowResize : <b>function</b>(){
        <b>if</b>(!<b>this</b>.grid.monitorWindowResize || <b>this</b>.grid.autoHeight){
            <b>return</b>;
        }
        <b>this</b>.updateWrapHeight();
    },
    
    appendFooter : <b>function</b>(parentEl){
        <b>return</b> null;  
    },

    sortAscText : 'Sort Ascending',
    sortDescText : 'Sort Descending',
    lockText : 'Lock Column',
    unlockText : 'Unlock Column',
    columnsText : 'Columns'
});
<b>if</b>(Ext.dd.DragZone){
Ext.grid.HeaderDragZone = <b>function</b>(grid, hd, hd2){
    <b>this</b>.grid = grid;
    <b>this</b>.view = grid.getView();
    <b>this</b>.ddGroup = 'gridHeader' + <b>this</b>.grid.container.id;
    Ext.grid.HeaderDragZone.superclass.constructor.call(<b>this</b>, hd);
    <b>this</b>.setHandleElId(YAHOO.util.Dom.generateId(hd));
    <b>this</b>.setOuterHandleElId(YAHOO.util.Dom.generateId(hd2));
    <b>this</b>.scroll = false;
};
Ext.extend(Ext.grid.HeaderDragZone, Ext.dd.DragZone, {
    maxDragWidth: 120,
    getDragData : <b>function</b>(e){
        <b>var</b> t = YAHOO.util.Event.getTarget(e);
        <b>var</b> h = <b>this</b>.view.findHeaderCell(t);
        <b>if</b>(h){
            <b>return</b> {ddel: h.firstChild, header:h};
        }
        <b>return</b> false;
    },
    
    onInitDrag : <b>function</b>(e){
        <b>var</b> clone = <b>this</b>.dragData.ddel.cloneNode(true);
        clone.style.width = Math.min(<b>this</b>.dragData.header.offsetWidth,<b>this</b>.maxDragWidth) + 'px';
        <b>this</b>.proxy.update(clone);
        <b>return</b> true;
    }
});

Ext.grid.SplitDragZone = <b>function</b>(grid, hd, hd2){
    <b>this</b>.grid = grid;
    <b>this</b>.view = grid.getView();
    <b>this</b>.proxy = <b>this</b>.view.resizeProxy;
    Ext.grid.SplitDragZone.superclass.constructor.call(<b>this</b>, hd, 
        'gridSplitters' + <b>this</b>.grid.container.id, {
        dragElId : YAHOO.util.Dom.generateId(<b>this</b>.proxy.dom), resizeFrame:false
    });
    <b>this</b>.setHandleElId(YAHOO.util.Dom.generateId(hd));
    <b>this</b>.setOuterHandleElId(YAHOO.util.Dom.generateId(hd2));
    <b>this</b>.scroll = false;
};
Ext.extend(Ext.grid.SplitDragZone, YAHOO.util.DDProxy, {
    fly: Ext.Element.fly,
    
    b4StartDrag : <b>function</b>(x, y){
        <b>this</b>.view.headersDisabled = true;
        <b>this</b>.proxy.setHeight(<b>this</b>.view.mainWrap.getHeight());
        <b>var</b> w = <b>this</b>.cm.getColumnWidth(<b>this</b>.cellIndex);
        <b>var</b> minw = Math.max(w-<b>this</b>.grid.minColumnWidth, 0);
        <b>this</b>.resetConstraints();
        <b>this</b>.setXConstraint(minw, 1000);
        <b>this</b>.setYConstraint(0, 0);
        <b>this</b>.minX = x - minw;
        <b>this</b>.maxX = x + 1000;
        <b>this</b>.startPos = x;
        YAHOO.util.DDProxy.prototype.b4StartDrag.call(<b>this</b>, x, y);
    },
    
    
    handleMouseDown : <b>function</b>(e){
        ev = Ext.EventObject.setEvent(e);
        <b>var</b> t = <b>this</b>.fly(ev.getTarget());
        <b>if</b>(t.hasClass('x-grid-split')){
            <b>this</b>.cellIndex = <b>this</b>.view.getCellIndex(t.dom);
            <b>this</b>.split = t.dom;
            <b>this</b>.cm = <b>this</b>.grid.colModel;
            <b>if</b>(this.cm.isResizable(<b>this</b>.cellIndex) &amp;&amp; !<b>this</b>.cm.isFixed(<b>this</b>.cellIndex)){
                Ext.grid.SplitDragZone.superclass.handleMouseDown.apply(<b>this</b>, arguments);
            }
        }
    },
    
    endDrag : <b>function</b>(e){
        <b>this</b>.view.headersDisabled = false;
        <b>var</b> endX = YAHOO.util.Event.getPageX(e);
        <b>var</b> diff = endX - <b>this</b>.startPos;
        <b>this</b>.view.onColumnSplitterMoved(<b>this</b>.cellIndex, <b>this</b>.cm.getColumnWidth(<b>this</b>.cellIndex)+diff);
    },
    
    autoOffset : <b>function</b>(){
        <b>this</b>.setDelta(0,0);
    }
});
Ext.grid.HeaderDropZone = <b>function</b>(grid, hd, hd2){
    <b>this</b>.grid = grid;
    <b>this</b>.view = grid.getView();
    <i>// split the proxies so they don't interfere <b>with</b> mouse events</i>
    <b>this</b>.proxyTop = Ext.DomHelper.append(document.body, {
        tag:'div', cls:'col-move-top', html:'&amp;#160;'
    }, true);
    <b>this</b>.proxyBottom = Ext.DomHelper.append(document.body, {
        tag:'div', cls:'col-move-bottom', html:'&amp;#160;'
    }, true);
    <b>this</b>.proxyTop.hide = <b>this</b>.proxyBottom.hide = <b>function</b>(){
        <b>this</b>.setLeftTop(-100,-100);
        <b>this</b>.setStyle('visibility', 'hidden');  
    };
    <b>this</b>.ddGroup = 'gridHeader' + <b>this</b>.grid.container.id;
    <i>// temporarily disabled</i>
    <i>//Ext.dd.ScrollManager.register(<b>this</b>.view.scroller.dom);</i>
    Ext.grid.HeaderDropZone.superclass.constructor.call(<b>this</b>, grid.container.dom);
};
Ext.extend(Ext.grid.HeaderDropZone, Ext.dd.DropZone, {
    proxyOffsets : [-4, -9],
    fly: Ext.Element.fly,
    
    getTargetFromEvent : <b>function</b>(e){
        <b>var</b> t = YAHOO.util.Event.getTarget(e);
        <b>var</b> cindex = <b>this</b>.view.findCellIndex(t);
        <b>if</b>(cindex !== false){
            <b>return</b> this.view.getHeaderCell(cindex);
        }
        <i>/*<b>else</b>{
            <b>return</b> this.grid.getHeaderFromChild(t);
        }*/</i>
    },
    
    nextVisible : <b>function</b>(h){
        <b>var</b> v = <b>this</b>.view, cm = <b>this</b>.grid.colModel;
        h = h.nextSibling;
        <b>while</b>(h){
            <b>if</b>(!cm.isHidden(v.getCellIndex(h))){
                <b>return</b> h;
            }
            h = h.nextSibling;
        }
        <b>return</b> null;
    },
    
    prevVisible : <b>function</b>(h){
        <b>var</b> v = <b>this</b>.view, cm = <b>this</b>.grid.colModel;
        h = h.prevSibling;
        <b>while</b>(h){
            <b>if</b>(!cm.isHidden(v.getCellIndex(h))){
                <b>return</b> h;
            }
            h = h.prevSibling;
        }
        <b>return</b> null;
    },
    
    positionIndicator : <b>function</b>(h, n, e){
        <b>var</b> x = YAHOO.util.Event.getPageX(e);
        <b>var</b> r = YAHOO.util.Dom.getRegion(n.firstChild);
        <b>var</b> px, pt, py = r.top + <b>this</b>.proxyOffsets[1];
        <b>if</b>((r.right - x) &lt;= (r.right-r.left)/2){
            px = r.right+<b>this</b>.view.borderWidth;
            pt = 'after';
        }<b>else</b>{
            px = r.left;
            pt = 'before';
        }
        <b>var</b> oldIndex = <b>this</b>.view.getCellIndex(h);
        <b>var</b> newIndex = <b>this</b>.view.getCellIndex(n);
        <b>var</b> locked = <b>this</b>.grid.colModel.isLocked(newIndex);
        <b>if</b>(pt == 'after'){
            newIndex++;
        }
        <b>if</b>(oldIndex &lt; newIndex){
            newIndex--;
        }
        <b>if</b>(oldIndex == newIndex &amp;&amp; (locked == <b>this</b>.grid.colModel.isLocked(oldIndex))){
            <b>return</b> false;
        }
        px +=  <b>this</b>.proxyOffsets[0];
        <b>this</b>.proxyTop.setLeftTop(px, py);
        <b>this</b>.proxyTop.show();
        <b>if</b>(!<b>this</b>.bottomOffset){
            <b>this</b>.bottomOffset = <b>this</b>.view.mainHd.getHeight();
        }
        <b>this</b>.proxyBottom.setLeftTop(px, py+<b>this</b>.proxyTop.dom.offsetHeight+<b>this</b>.bottomOffset);
        <b>this</b>.proxyBottom.show();
        <b>return</b> pt;
    },
    
    onNodeEnter : <b>function</b>(n, dd, e, data){
        <b>if</b>(data.header != n){
            <b>this</b>.positionIndicator(data.header, n, e);
        }
    },
    
    onNodeOver : <b>function</b>(n, dd, e, data){
        <b>var</b> result = false;
        <b>if</b>(data.header != n){
            result = <b>this</b>.positionIndicator(data.header, n, e);
        }
        <b>if</b>(!result){
            <b>this</b>.proxyTop.hide();
            <b>this</b>.proxyBottom.hide();
        }
        <b>return</b> result ? <b>this</b>.dropAllowed : <b>this</b>.dropNotAllowed;
    },
    
    onNodeOut : <b>function</b>(n, dd, e, data){
        <b>this</b>.proxyTop.hide();
        <b>this</b>.proxyBottom.hide();
    },
    
    onNodeDrop : <b>function</b>(n, dd, e, data){
        <b>var</b> h = data.header;
        <b>if</b>(h != n){
            <b>var</b> cm = <b>this</b>.grid.colModel;
            <b>var</b> x = YAHOO.util.Event.getPageX(e);
            <b>var</b> r = YAHOO.util.Dom.getRegion(n.firstChild);
            <b>var</b> pt = (r.right - x) &lt;= ((r.right-r.left)/2) ? 'after' : 'before';
            <b>var</b> oldIndex = <b>this</b>.view.getCellIndex(h);
            <b>var</b> newIndex = <b>this</b>.view.getCellIndex(n);
            <b>var</b> locked = cm.isLocked(newIndex);
            <b>if</b>(pt == 'after'){
                newIndex++;
            }
            <b>if</b>(oldIndex &lt; newIndex){
                newIndex--;
            }
            <b>if</b>(oldIndex == newIndex &amp;&amp; (locked == cm.isLocked(oldIndex))){
                <b>return</b> false;
            }
            cm.setLocked(oldIndex, locked, true);
            cm.moveColumn(oldIndex, newIndex);
            <b>this</b>.grid.fireEvent('columnmove', oldIndex, newIndex);
            <b>return</b> true;
        }
        <b>return</b> false;
    }
});
}
</code></pre><hr><div style="font-size:10px;text-align:center;color:gray;">yui-ext - Copyright &copy; 2006 Jack Slocum.  |
    Yahoo! UI - Copyright &copy; 2006 Yahoo! Inc.<br />All rights reserved.</div>
    </body></html>